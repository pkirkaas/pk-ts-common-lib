var d = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var y = d((i) => {
  const g = (e) => typeof e == "object" && e != null && !(e instanceof Boolean) && !(e instanceof Date) && !(e instanceof Number) && !(e instanceof RegExp) && !(e instanceof String), b = (e) => "#" + e.map((t) => String(t).replace(/~/g, "~0").replace(/\//g, "~1")).join("/"), h = () => {
    const e = new i.WeakMap();
    return function(n, r) {
      if (n !== "$ref" && g(r)) {
        if (e.has(r))
          return { $ref: b(e.get(r)) };
        e.set(r, [...e.get(this) ?? [], n]);
      }
      return r;
    };
  };
  function l() {
    const e = new i.WeakMap(), t = new i.WeakMap(), n = new i.Set();
    function r(o) {
      const c = o.$ref.slice(1).split("/");
      let s, f, a = this;
      for (var p = 0; p < c.length; p++)
        s = c[p].replace(/~1/g, "/").replace(/~0/g, "~"), a = a[s];
      f = e.get(o), f[t.get(o)] = a;
    }
    return function(c, s) {
      if (c === "$ref")
        n.add(this);
      else if (g(s)) {
        var f = c === "" && Object.keys(this).length === 1;
        f ? n.forEach(r, this) : (e.set(s, this), t.set(s, c));
      }
      return s;
    };
  }
  const j = (e) => Object.defineProperties(e, {
    decycle: {
      value: (t, n) => e.stringify(t, h(), n)
    },
    retrocycle: {
      value: (t) => e.parse(t, l())
    }
  });
  Object.assign(i, {
    decycle: h,
    retrocycle: l,
    extend: j
  });
});
export default y();
